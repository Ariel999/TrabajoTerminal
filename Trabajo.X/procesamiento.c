#include <xc.h>
#include <dsp.h>
#include <math.h>
#include "defs.h"
#define M_PI 3.14159265358979323846

typedef struct{
	float real;
	float imag;
} complejo;
 
extern fractcomplex valCH0[FFT_BLOCK_LENGTH]
__attribute__ ((eds, space(ymemory), aligned (FFT_BLOCK_LENGTH * 2 *2)));

 #ifndef FFTTWIDCOEFFS_IN_PROGMEM
 fractcomplex twiddleFactors[FFT_BLOCK_LENGTH/2] 	
 __attribute__ ((section (".xbss, bss, xmemory"), aligned (FFT_BLOCK_LENGTH*2)));
 #else
 extern const fractcomplex twiddleFactors[FFT_BLOCK_LENGTH/2]	/* Twiddle Factor array in Program memory */
 __attribute__ ((space(prog), aligned (FFT_BLOCK_LENGTH*2)));
 #endif

extern fractional valCH1[MUESTRAS];
float valCH0Float[MUESTRAS], valCH1Float[MUESTRAS];
float epochs[MUESTRAS];
float var;
int	peakFrequencyBin = 0;				/* Declare post-FFT variables to compute the */
unsigned long peakFrequency = 0;
fractional output[FFT_BLOCK_LENGTH];
const float prueba[] = 
{
    0.000000,0.290285,0.555570,0.773010,0.923880,0.995185,0.980785,0.881921,
    0.707107,0.471397,0.195090,-0.098017,-0.382683,-0.634393,-0.831470,
    -0.956940,-1.000000,-0.956940,-0.831470,-0.634393,-0.382683,-0.098017,
    0.195090,0.471397,0.707107,0.881921,0.980785,0.995185,0.923880,
    0.773010,0.555570,0.290285,0.000000,-0.290285,-0.555570,-0.773010,
    -0.923880,-0.995185,-0.980785,-0.881921,-0.707107,-0.471397,-0.195090,
    0.098017,0.382683,0.634393,0.831470,0.956940,1.000000,0.956940,
    0.831470,0.634393,0.382683,0.098017,-0.195090,-0.471397,-0.707107,
    -0.881921,-0.980785,-0.995185,-0.923880,-0.773010,-0.555570,-0.290285,
    -0.000000,0.290285,0.555570,0.773010,0.923880,0.995185,0.980785,
    0.881921,0.707107,0.471397,0.195090,-0.098017,-0.382683,-0.634393,
    -0.831470,-0.956940,-1.000000,-0.956940,-0.831470,-0.634393,-0.382683,
    -0.098017,0.195090,0.471397,0.707107,0.881921,0.980785,0.995185,
    0.923880,0.773010,0.555570,0.290285,0.000000,-0.290285,-0.555570,
    -0.773010,-0.923880,-0.995185,-0.980785,-0.881921,-0.707107,-0.471397,
    -0.195090,0.098017,0.382683,0.634393,0.831470,0.956940,1.000000,
    0.956940,0.831470,0.634393,0.382683,0.098017,-0.195090,-0.471397,
    -0.707107,-0.881921,-0.980785,-0.995185,-0.923880,-0.773010,-0.555570,
    -0.290285,-0.000000,0.290285,0.555570,0.773010,0.923880,0.995185,
    0.980785,0.881921,0.707107,0.471397,0.195090,-0.098017,-0.382683,
    -0.634393,-0.831470,-0.956940,-1.000000,-0.956940,-0.831470,-0.634393,
    -0.382683,-0.098017,0.195090,0.471397,0.707107,0.881921,0.980785,
    0.995185,0.923880,0.773010,0.555570,0.290285,0.000000,-0.290285,
    -0.555570,-0.773010,-0.923880,-0.995185,-0.980785,-0.881921,-0.707107,
    -0.471397,-0.195090,0.098017,0.382683,0.634393,0.831470,0.956940,
    1.000000,0.956940,0.831470,0.634393,0.382683,0.098017,-0.195090,
    -0.471397,-0.707107,-0.881921,-0.980785,-0.995185,-0.923880,-0.773010,
    -0.555570,-0.290285,-0.000000,0.290285,0.555570,0.773010,0.923880,
    0.995185,0.980785,0.881921,0.707107,0.471397,0.195090,-0.098017,
    -0.382683,-0.634393,-0.831470,-0.956940,-1.000000,-0.956940,-0.831470,
    -0.634393,-0.382683,-0.098017,0.195090,0.471397,0.707107,0.881921,
    0.980785,0.995185,0.923880,0.773010,0.555570,0.290285,-0.000000,
    -0.290285,-0.555570,-0.773010,-0.923880,-0.995185,-0.980785,-0.881921,
    -0.707107,-0.471397,-0.195090,0.098017,0.382683,0.634393,0.831470,
    0.956940,1.000000,0.956940,0.831470,0.634393,0.382683,0.098017,
    -0.195090,-0.471397,-0.707107,-0.881921,-0.980785,-0.995185,-0.923880,
    -0.773010,-0.555570,-0.290285
};
const float hamming_coef[] = 
{
    0.080000,0.080140,0.080558,0.081256,0.082232,0.083487,0.085018,0.086825,
    0.088908,0.091264,0.093893,0.096793,0.099962,0.103398,0.107099,0.111063,
    0.115287,0.119769,0.124506,0.129496,0.134734,0.140219,0.145946,0.151913,
    0.158115,0.164549,0.171211,0.178097,0.185203,0.192524,0.200056,0.207794,
    0.215734,0.223871,0.232200,0.240716,0.249413,0.258287,0.267332,0.276542,
    0.285912,0.295437,0.305110,0.314925,0.324878,0.334960,0.345168,0.355493,
    0.365931,0.376474,0.387117,0.397852,0.408674,0.419575,0.430550,0.441591,
    0.452691,0.463845,0.475045,0.486285,0.497557,0.508854,0.520171,0.531500,
    0.542834,0.554166,0.565489,0.576797,0.588083,0.599340,0.610560,0.621738,
    0.632866,0.643938,0.654946,0.665885,0.676747,0.687527,0.698216,0.708810,
    0.719302,0.729684,0.739951,0.750097,0.760115,0.770000,0.779745,0.789345,
    0.798793,0.808084,0.817212,0.826172,0.834958,0.843565,0.851988,0.860222,
    0.868261,0.876100,0.883736,0.891163,0.898377,0.905373,0.912148,0.918696,
    0.925015,0.931100,0.936947,0.942554,0.947916,0.953030,0.957894,0.962504,
    0.966857,0.970952,0.974785,0.978353,0.981656,0.984690,0.987455,0.989948,
    0.992168,0.994113,0.995782,0.997175,0.998290,0.999128,0.999686,0.999965,
    0.999965,0.999686,0.999128,0.998290,0.997175,0.995782,0.994113,0.992168,
    0.989948,0.987455,0.984690,0.981656,0.978353,0.974785,0.970952,0.966857,
    0.962504,0.957894,0.953030,0.947916,0.942554,0.936947,0.931100,0.925015,
    0.918696,0.912148,0.905373,0.898377,0.891163,0.883736,0.876100,0.868261,
    0.860222,0.851988,0.843565,0.834958,0.826172,0.817212,0.808084,0.798793,
    0.789345,0.779745,0.770000,0.760115,0.750097,0.739951,0.729684,0.719302,
    0.708810,0.698216,0.687527,0.676747,0.665885,0.654946,0.643938,0.632866,
    0.621738,0.610560,0.599340,0.588083,0.576797,0.565489,0.554166,0.542834,
    0.531500,0.520171,0.508854,0.497557,0.486285,0.475045,0.463845,0.452691,
    0.441591,0.430550,0.419575,0.408674,0.397852,0.387117,0.376474,0.365931,
    0.355493,0.345168,0.334960,0.324878,0.314925,0.305110,0.295437,0.285912,
    0.276542,0.267332,0.258287,0.249413,0.240716,0.232200,0.223871,0.215734,
    0.207794,0.200056,0.192524,0.185203,0.178097,0.171211,0.164549,0.158115,
    0.151913,0.145946,0.140219,0.134734,0.129496,0.124506,0.119769,0.115287,
    0.111063,0.107099,0.103398,0.099962,0.096793,0.093893,0.091264,0.088908,
    0.086825,0.085018,0.083487,0.082232,0.081256,0.080558,0.080140,0.080000
};


void procesarMuestras( )
{
    
    int i = 0;
    //fractional *p_real = &valCH0[0].real ;
	//fractcomplex *p_cmpx = &valCH0[0] ;
    
    #ifndef FFTTWIDCOEFFS_IN_PROGMEM					
    TwidFactorInit (LOG2_BLOCK_LENGTH, &twiddleFactors[0], 0);	
    #endif
    
    for ( i = 0; i < FFT_BLOCK_LENGTH; i++ )/* The FFT function requires input data */
    {					/* to be in the fractional fixed-point range [-0.5, +0.5]*/
        valCH0[i].real = valCH0[i].real >> 1 ;		/* So, we shift all data samples by 1 bit to the right. */
        valCH0[i].imag = 0;			/* Should you desire to optimize this process, perform */
    }
    #ifndef FFTTWIDCOEFFS_IN_PROGMEM
    FFTComplexIP (LOG2_BLOCK_LENGTH, &sigCmpx[0], &twiddleFactors[0], COEFFS_IN_DATA);
    #else
    FFTComplexIP (LOG2_BLOCK_LENGTH, &valCH0[0], (fractcomplex *) __builtin_psvoffset(&twiddleFactors[0]), (int) __builtin_psvpage(&twiddleFactors[0]));
    #endif
    
    BitReverseComplex (LOG2_BLOCK_LENGTH, &valCH0[0]);
    
    SquareMagnitudeCplx(FFT_BLOCK_LENGTH, &valCH0[0], output);
    
    VectorMax(FFT_BLOCK_LENGTH/2, output, &peakFrequencyBin);
    
    peakFrequency = peakFrequencyBin*(256/FFT_BLOCK_LENGTH);
    
    while(1);
    
    return;
}
/*void convertirDatos(char canal)
{
    int i = 0;
    for( i = 0; i < MUESTRAS; i++ )
    {
        if( canal == 0 )
        {
            if( (valCH0[i] & 0x8000) == 0x8000)
            {
                var = ((~(valCH0[i] & 0x7FFF)) >> 6) & 0x01FF;
                valCH0Float[i] = - var * 0.00322265625;
            }
            else
            {
                var = (valCH0[i] >> 6);
                valCH0Float[i] = var * 0.00322265625;//0.00322265625
            }
        }
        else
        {
            if( (valCH1[i] & 0x8000) == 0x8000)
            {
                var = ((~(valCH1[i] & 0x7FFF)) >> 6) & 0x01FF;
                valCH1Float[i] = - var * 0.00322265625;
            }
            else
            {
                var = (valCH1[i] >> 6);
                valCH1Float[i] = var * 0.00322265625;
            }
            
        }
    }
}*/
void procesarEPOC( void )
{
    int i,j;
	for( i=0;i<MUESTRAS;i++)
    {
		//epochs[i] = valCH0Float[i]*hamming_coef[i];
        epochs[i] = prueba[i]*hamming_coef[i];
	}
    complejo fft[MUESTRAS];
    
    for( i=0;i<MUESTRAS;i++)
    {
		fft[i].real=0.0;
		fft[i].imag=0.0;
	}
    
    float var1;
	for(i=0;i<MUESTRAS;i++)
    {
		for(j=0;j<MUESTRAS;j++)
        {
            var1 = 2*M_PI*i*j/MUESTRAS;
			float real = (float)cos((double)var1);
			float imag = (float)sin((double)var1);
			fft[i].real+=(epochs[j]*real);
			fft[i].imag+=(epochs[j]*imag);				
		}
	}
    
    
	for( i=0;i<MUESTRAS;i++)
    {
        float real = fft[i].real/MUESTRAS;
		float imag = fft[i].imag/MUESTRAS;

		epochs[i]=(float)sqrt(pow((double)real,2.0)+pow((double)imag,2.0));	
	}
    
    return;
}